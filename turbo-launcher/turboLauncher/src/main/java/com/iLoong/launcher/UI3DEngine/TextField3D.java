/*******************************************************************************
 * Copyright 2011 See AUTHORS file.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 * implied. See the License for the specific language governing permissions and limitations under the License.
 ******************************************************************************/
package com.iLoong.launcher.UI3DEngine;


import java.util.List;

import android.graphics.Paint;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input.Keys;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.NinePatch;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.scenes.scene2d.Actor;
import com.badlogic.gdx.scenes.scene2d.Group;
import com.badlogic.gdx.scenes.scene2d.ui.utils.Clipboard;
import com.iLoong.RR;
import com.iLoong.launcher.Desktop3D.ApplicationListHost;
import com.iLoong.launcher.Desktop3D.Log;
import com.iLoong.launcher.Desktop3D.R3D;
import com.iLoong.launcher.Desktop3D.SendMsgToAndroid;
import com.iLoong.launcher.Folder3D.FolderMIUI3D;


/**
 * A single-line text input field.
 * <p>
 * The preferred height of a text field is the height of the
 * {@link TextFieldStyle#font} and {@link TextFieldStyle#background}. The
 * preferred width of a text field is 150, a relatively arbitrary size.
 * <p>
 * The text field will copy the currently selected text when ctrl+c is pressed,
 * and paste any text in the clipboard when ctrl+v is pressed. Clipboard
 * functionality is provided via the {@link Clipboard} interface. Currently
 * there are two standard implementations, one for the desktop and one for
 * Android. The Android clipboard is a stub, as copy & pasting on Android is not
 * supported yet.
 * <p>
 * The text field allows you to specify an {@link OnscreenKeyboard} for
 * displaying a softkeyboard and piping all key events generated by the keyboard
 * to the text field. There are two standard implementations, one for the
 * desktop and one for Android. The desktop keyboard is a stub, as a
 * softkeyboard is not needed on the desktop. The Android
 * {@link OnscreenKeyboard} implementation will bring up the default IME.
 * 
 * @author mzechner
 */
public class TextField3D extends View3D
{
	
	static private final char BACKSPACE = 8;
	static private final char ENTER_DESKTOP = '\r';
	static private final char ENTER_ANDROID = '\n';
	static private final char TAB = '\t';
	static private final char DELETE = 127;
	static private final char BULLET = 149;
	public int CHARNUM = Integer.MAX_VALUE;
	private float inputText_X = 0f;
	private String text = "";
	private String messageText;
	private String displayText;
	private int cursor;
	private Clipboard clipboard;
	private TextFieldListener listener;
	private TextFieldFilter filter;
	private OnscreenKeyboard keyboard = new DefaultOnscreenKeyboard();
	private DisplayTextFormatter textFormater = new DefaultTextureDefaultFormatter();
	private DisplayTextFormatter textOpacityFormatter = new DisplayOpacityTextFormatter();
	private KeyboardAdapter keyboardAdapter = null;
	private boolean passwordMode;
	private StringBuilder passwordBuffer;
	private int visibleTextEnd;
	private boolean cursorOn = true;
	private float blinkTime = 0.42f;
	private long lastBlink;
	private boolean hasSelection;
	private int selectionStart;
	private char passwordCharacter = BULLET;
	private NinePatch cursorPatch = null;
	private TextureRegion displayTextTexture;
	private float displayOffsetX;
	private Paint paint;
	float cursorHeight = 0f;
	private boolean editable = false;
	private boolean openAction = false;
	private boolean mediate = true;
	
	public boolean isOpenAction()
	{
		return openAction;
	}
	
	public void setOpenAction(
			boolean openAction )
	{
		this.openAction = openAction;
	}
	
	/**
	 * @param messageText
	 *            Text to show when empty. May be null.
	 */
	private TextField3D()
	{
		super( "text_field" );
	}
	
	public TextField3D(
			String name ,
			float width ,
			float height ,
			Paint paint )
	{
		super( name );
		if( paint == null )
			throw new IllegalArgumentException( "paint cannot be null." );
		this.width = width;
		this.height = height;
		this.paint = paint;
		cursorPatch = new NinePatch( R3D.findRegion( "cursor_patch" ) , 1 , 1 , 0 , 0 );
		this.clipboard = Clipboard.getDefaultClipboard();
		cursorHeight = (float)Math.ceil( paint.getFontMetrics().descent - paint.getFontMetrics().ascent );
		textFormater.setPaint( paint );
		textOpacityFormatter.setPaint( paint );
	}
	
	public KeyboardAdapter getKeyboardAdapter()
	{
		return keyboardAdapter;
	}
	
	public void setKeyboardAdapter(
			KeyboardAdapter keyboardAdapter )
	{
		this.keyboardAdapter = keyboardAdapter;
	}
	
	public void setPasswordCharacter(
			char passwordCharacter )
	{
		this.passwordCharacter = passwordCharacter;
	}
	
	private void calculateOffsets()
	{
		String temdisplayText = null;
		if( displayText != null && displayText.length() > 0 )
		{
			temdisplayText = text.substring( 0 , cursor );
			if( temdisplayText.length() > displayText.length() )
			{
				visibleTextEnd = (int)paint.measureText( displayText );
			}
			else
			{
				visibleTextEnd = (int)paint.measureText( temdisplayText );
			}
		}
		else
		{
			visibleTextEnd = 0;
		}
	}
	
	@Override
	public void draw(
			SpriteBatch batch ,
			float parentAlpha )
	{
		super.draw( batch , parentAlpha );
		batch.setColor( color.r , color.g , color.b , color.a * parentAlpha );
		boolean focused = stage != null && stage.getKeyboardFocus() == this;
		if( displayTextTexture != null )
		{
			batch.draw( displayTextTexture , x + ( mediate ? displayOffsetX : 0 ) , y );
		}
		if( focused && editable )
		{
			blink();
			if( cursorOn && cursorPatch != null )
			{
				cursorPatch.draw( batch , x + ( mediate ? displayOffsetX : 0 ) + visibleTextEnd , y + ( this.height - cursorHeight ) / 2 , cursorPatch.getTotalWidth() , cursorHeight );
			}
			Gdx.graphics.requestRendering();
		}
	}
	
	public void setMediate(
			boolean mediate )
	{
		this.mediate = mediate;
	}
	
	public boolean isEditable()
	{
		return editable;
	}
	
	public void setEditable(
			boolean editable )
	{
		this.editable = editable;
	}
	
	@Override
	public boolean onClick(
			float x ,
			float y )
	{
		return false;
	}
	
	public void clear()
	{
		this.text = "";
		updateDisplayText();
		cursor = 0;
		if( listener != null )
		{
			listener.valueChanged( this , text );
		}
	}
	
	private void updateDisplayText()
	{
		if( passwordMode )
		{
			if( passwordBuffer == null )
				passwordBuffer = new StringBuilder( text.length() );
			if( passwordBuffer.length() > text.length() ) //
				passwordBuffer.setLength( text.length() );
			else
			{
				for( int i = passwordBuffer.length() , n = text.length() ; i < n ; i++ )
					passwordBuffer.append( passwordCharacter );
			}
			displayText = passwordBuffer.toString();
		}
		else
		{
			displayText = text;
		}
		displayText = textFormater.formatDisplayTitle( displayText , (int)( (int)width - 1 * 30 * UtilsBase.getScreenWidth() / 720f ) , (int)height );
		displayOffsetX = ( this.width - paint.measureText( displayText ) ) / 2;
		if( displayOffsetX < 0 )
		{
			displayOffsetX = 0;
		}
		calculateOffsets();
		this.inputText_X = mediate ? displayOffsetX : 0;
		Texture oldTexture = null;
		if( this.displayTextTexture != null && displayTextTexture.getTexture() != null )
		{
			oldTexture = displayTextTexture.getTexture();
			TextureRegion newRegion = textFormater.getDisplayTexture( displayText , (int)width , (int)height );
			displayTextTexture.setRegion( newRegion );
			if( oldTexture != null )
			{
				oldTexture.dispose();
			}
		}
		else
		{
			displayTextTexture = textFormater.getDisplayTexture( displayText , (int)width , (int)height );
		}
	}
	
	public void updateDisplayOpacityText()
	{
		String displayText;
		if( passwordMode )
		{
			if( passwordBuffer == null )
				passwordBuffer = new StringBuilder( text.length() );
			if( passwordBuffer.length() > text.length() ) //
				passwordBuffer.setLength( text.length() );
			else
			{
				for( int i = passwordBuffer.length() , n = text.length() ; i < n ; i++ )
					passwordBuffer.append( passwordCharacter );
			}
			displayText = passwordBuffer.toString();
		}
		else
		{
			displayText = text;
		}
		displayText = textOpacityFormatter.formatDisplayTitle( displayText , (int)( (int)width - 1 * 30 * UtilsBase.getScreenWidth() / 720f ) , (int)height );
		displayOffsetX = ( this.width - paint.measureText( displayText ) ) / 2;
		if( displayOffsetX < 0 )
		{
			displayOffsetX = 0;
		}
		calculateOffsets();
		this.inputText_X = mediate ? displayOffsetX : 0;
		Texture oldTexture = null;
		if( this.displayTextTexture != null && displayTextTexture.getTexture() != null )
		{
			oldTexture = displayTextTexture.getTexture();
			TextureRegion newRegion = textOpacityFormatter.getDisplayTexture( displayText , (int)width , (int)height );
			displayTextTexture.setRegion( newRegion );
			if( oldTexture != null )
			{
				oldTexture.dispose();
			}
		}
		else
		{
			displayTextTexture = textOpacityFormatter.getDisplayTexture( displayText , (int)width , (int)height );
		}
	}
	
	private void blink()
	{
		long time = System.nanoTime();
		if( ( time - lastBlink ) / 1000000000.0f > blinkTime )
		{
			cursorOn = !cursorOn;
			lastBlink = time;
		}
	}
	
	public int FindCursorPosition(
			String title ,
			float edit_title_X ,
			float x )
	{
		String tmpTitle = title;
		int temcursor = 0;
		float titleWidth = paint.measureText( tmpTitle );
		if( titleWidth <= this.width )
		{
			for( int i = 1 ; i <= title.length() ; i++ )
			{
				tmpTitle = title.substring( 0 , i );
				float s = paint.measureText( tmpTitle );
				if( ( s <= this.width ) && ( s <= ( x - edit_title_X ) ) )
				{
					temcursor++;
				}
			}
			cursor = temcursor;
		}
		updateDisplayText();
		return cursor;
	}
	
	@Override
	public boolean onTouchDown(
			float x ,
			float y ,
			int pointer )
	{
		if( editable )
		{
			if( pointer != 0 )
				return false;
			if( stage != null )
				stage.setKeyboardFocus( this );
			//			keyboard.show(true);
			if( keyboardAdapter != null )
			{
				keyboardAdapter.onKeyboardOpen( this );
			}
			FindCursorPosition( displayText , inputText_X , x );
			openAction = true;
			clearSelection();
			lastBlink = 0;
			cursorOn = false;
			return true;
		}
		else
		{
			return false;
		}
	}
	
	public void popKeyBoard()
	{
		if( stage != null )
			stage.setKeyboardFocus( this );
		keyboard.show( true );
		if( keyboardAdapter != null )
		{
			keyboardAdapter.onKeyboardOpen( this );
		}
		clearSelection();
		lastBlink = 0;
		cursorOn = false;
	}
	
	public void showInputKeyboard()
	{
		if( editable )
		{
			if( stage != null )
				stage.setKeyboardFocus( this );
			keyboard.show( true );
			if( keyboardAdapter != null )
			{
				keyboardAdapter.onKeyboardOpen( this );
			}
			openAction = true;
			clearSelection();
			lastBlink = 0;
			cursorOn = false;
		}
	}
	
	public void hideInputKeyboard()
	{
		if( stage != null )
			stage.setKeyboardFocus( null );
		if( keyboardAdapter != null )
		{
			keyboardAdapter.onKeyboardClose( this );
		}
		keyboard.show( false );
		lastBlink = 0;
		cursorOn = false;
	}
	
	public boolean keyDown(
			int keycode )
	{
		if( stage != null && stage.getKeyboardFocus() == this )
		{
			if( Gdx.input.isKeyPressed( Keys.CONTROL_LEFT ) || Gdx.input.isKeyPressed( Keys.CONTROL_RIGHT ) )
			{
				// paste
				if( keycode == Keys.V )
					paste();
				// copy
				if( keycode == Keys.C || keycode == Keys.INSERT )
					copy();
			}
			else if( Gdx.input.isKeyPressed( Keys.SHIFT_LEFT ) || Gdx.input.isKeyPressed( Keys.SHIFT_RIGHT ) )
			{
				// paste
				if( keycode == Keys.INSERT )
					paste();
				// cut
				if( keycode == Keys.FORWARD_DEL )
				{
					if( hasSelection )
					{
						copy();
						delete();
					}
				}
				// selection
				if( keycode == Keys.LEFT )
				{
					if( !hasSelection )
					{
						selectionStart = cursor;
						hasSelection = true;
					}
					cursor--;
				}
				if( keycode == Keys.RIGHT )
				{
					if( !hasSelection )
					{
						selectionStart = cursor;
						hasSelection = true;
					}
					cursor++;
				}
				if( keycode == Keys.HOME )
				{
					if( !hasSelection )
					{
						selectionStart = cursor;
						hasSelection = true;
					}
					cursor = 0;
				}
				if( keycode == Keys.END )
				{
					if( !hasSelection )
					{
						selectionStart = cursor;
						hasSelection = true;
					}
					cursor = text.length();
				}
				cursor = Math.max( 0 , cursor );
				cursor = Math.min( text.length() , cursor );
				updateDisplayText();
			}
			else
			{
				// cursor movement or other keys (kill selection)
				if( keycode == Keys.LEFT )
				{
					if( cursor <= 0 )
					{
						cursor = 0;
					}
					else
					{
						cursor--;
					}
					clearSelection();
				}
				if( keycode == Keys.RIGHT )
				{
					if( cursor >= CHARNUM )
					{
						cursor = CHARNUM;
					}
					else
					{
						cursor++;
					}
					clearSelection();
				}
				if( keycode == Keys.HOME )
				{
					cursor = 0;
					clearSelection();
				}
				if( keycode == Keys.END )
				{
					cursor = text.length();
					clearSelection();
				}
				updateDisplayText();
				// cursor = Math.max(0, cursor);
				// cursor = Math.min(text.length(), cursor);
			}
			return true;
		}
		return false;
	}
	
	@Override
	public boolean keyUp(
			int keycode )
	{
		if( keycode == android.view.KeyEvent.KEYCODE_BACK )
		{
			hideInputKeyboard();
			openAction = false;
			return true;
		}
		return false;
	}
	
	private void copy()
	{
		if( hasSelection )
		{
			int minIndex = Math.min( cursor , selectionStart );
			int maxIndex = Math.max( cursor , selectionStart );
			clipboard.setContents( text.substring( minIndex , maxIndex ) );
		}
	}
	
	private void paste()
	{
		String content = clipboard.getContents();
		if( content != null )
		{
			StringBuilder builder = new StringBuilder();
			for( int i = 0 ; i < content.length() ; i++ )
			{
				char c = content.charAt( i );
				builder.append( c );
			}
			content = builder.toString();
			text = text.substring( 0 , cursor ) + content + text.substring( cursor , text.length() );
			cursor += content.length();
			updateDisplayText();
		}
	}
	
	private void delete()
	{
		int minIndex = Math.min( cursor , selectionStart );
		int maxIndex = Math.max( cursor , selectionStart );
		text = ( minIndex > 0 ? text.substring( 0 , minIndex ) : "" ) + ( maxIndex < text.length() ? text.substring( maxIndex , text.length() ) : "" );
		cursor = minIndex;
		updateDisplayText();
		clearSelection();
	}
	
	public boolean keyTyped(
			char character )
	{
		int temIndex = 0;
		int start = 0;
		int end = 0;
		if( stage != null && stage.getKeyboardFocus() == this && editable )
		{
			if( character == BACKSPACE )
			{
				if( ( cursor > 0 || hasSelection ) )
				{
					if( !hasSelection )
					{
						temIndex = text.indexOf( displayText );
						end = temIndex + cursor - 1;
						if( end > text.length() )
						{
							end = text.length();
						}
						start = temIndex + cursor;
						if( start > text.length() )
						{
							start = text.length();
						}
						text = text.substring( 0 , end ) + text.substring( start );
						if( Utils3D.measureText( paint , text ) <= this.width )
						{
							cursor--;
						}
						updateDisplayText();
					}
					else
					{
						delete();
					}
				}
			}
			if( character == DELETE )
			{
				if( cursor < text.length() || hasSelection )
				{
					if( !hasSelection )
					{
						text = text.substring( 0 , cursor ) + text.substring( cursor + 1 );
						updateDisplayText();
					}
					else
					{
						delete();
					}
				}
				return true;
			}
			if( character != ENTER_DESKTOP && character != ENTER_ANDROID )
			{
				if( filter != null && !filter.acceptChar( this , character ) )
					return true;
			}
			if( character == TAB || character == ENTER_ANDROID )
				next( Gdx.input.isKeyPressed( Keys.SHIFT_LEFT ) || Gdx.input.isKeyPressed( Keys.SHIFT_RIGHT ) );
			if( !hasSelection )
			{
				if( String.valueOf( character ).trim().length() > 0 )
				{
					if( listener instanceof FolderMIUI3D ||listener instanceof ApplicationListHost)
					{
						if( text.length() + String.valueOf( character ).trim().length() > 20 )
						{
							SendMsgToAndroid.sendOurToastMsg( R3D.getString( RR.string.text_name_max_length ) );
							return true;
						}
					}
					if( text.length() > CHARNUM - 1 )
					{
						SendMsgToAndroid.sendOurToastMsg( R3D.getString( RR.string.text_name_max_length ) );
					}
					else
					{
						temIndex = text.indexOf( displayText );
						end = temIndex + cursor;
						if( end > text.length() )
						{
							end = text.length();
						}
						start = temIndex + cursor;
						if( start > text.length() )
						{
							start = text.length();
						}
						text = text.substring( 0 , end ) + character + text.substring( start , text.length() );
						if( Utils3D.measureText( paint , text ) <= this.width )
						{
							cursor++;
						}
						updateDisplayText();
					}
				}
			}
			else
			{
				if( String.valueOf( character ).trim().length() > 0 )
				{
					int minIndex = Math.min( cursor , selectionStart );
					int maxIndex = Math.max( cursor , selectionStart );
					text = ( minIndex > 0 ? text.substring( 0 , minIndex ) : "" ) + ( maxIndex < text.length() ? text.substring( maxIndex , text.length() ) : "" );
					cursor = minIndex;
					text = text.substring( 0 , cursor ) + character + text.substring( cursor , text.length() );
					cursor++;
					updateDisplayText();
					clearSelection();
				}
			}
			if( character == '\0' )
			{
				Log.e( "test" , "empty character" );
			}
			else
			{
				if( listener != null )
					listener.valueChanged( this , text );
			}
			return true;
		}
		else
			return false;
	}
	
	public boolean keyTyped(
			String characters )
	{
		int temIndex = 0;
		int start = 0;
		int end = 0;
		if( stage != null && stage.getKeyboardFocus() == this && editable )
		{
			if( characters == null || String.valueOf( characters ).trim().length() == 0 )
			{
				return true;
			}
			if( !hasSelection )
			{
				if( listener instanceof FolderMIUI3D  ||listener instanceof ApplicationListHost)
				{
					if( text.length() + String.valueOf( characters ).trim().length() > 8 )
					{
						SendMsgToAndroid.sendOurToastMsg( R3D.getString( RR.string.text_name_max_length ) );
						return true;
					}
				}
				if( text.length() > CHARNUM - 1 )
				{
					SendMsgToAndroid.sendOurToastMsg( R3D.getString( RR.string.text_name_max_length ) );
				}
				else
				{
					temIndex = text.indexOf( displayText );
					String newCharacters = characters.trim();
					if( text.length() + newCharacters.length() > CHARNUM - 1 )
					{
						SendMsgToAndroid.sendOurToastMsg( R3D.getString( RR.string.text_name_max_length ) );
						int subIndex = ( text.length() + newCharacters.length() ) - CHARNUM;
						newCharacters = newCharacters.substring( 0 , subIndex );
					}
					end = temIndex + cursor;
					if( end > text.length() )
					{
						end = text.length();
					}
					start = temIndex + cursor;
					if( start > text.length() )
					{
						start = text.length();
					}
					text = text.substring( 0 , end ) + newCharacters + text.substring( start , text.length() );
					if( Utils3D.measureText( paint , text ) <= this.width )
					{
						cursor = cursor + newCharacters.length();
					}
					updateDisplayText();
				}
			}
			else
			{
				int minIndex = Math.min( cursor , selectionStart );
				int maxIndex = Math.max( cursor , selectionStart );
				text = ( minIndex > 0 ? text.substring( 0 , minIndex ) : "" ) + ( maxIndex < text.length() ? text.substring( maxIndex , text.length() ) : "" );
				cursor = minIndex;
				text = text.substring( 0 , cursor ) + characters.trim() + text.substring( cursor , text.length() );
				cursor = cursor + characters.trim().length();
				updateDisplayText();
				clearSelection();
			}
			if( listener != null )
				listener.valueChanged( this , text );
			return true;
		}
		else
			return false;
	}
	
	/**
	 * Focuses the next TextField. If none is found, the keyboard is hidden.
	 * Does nothing if the text field is not in a stage.
	 * 
	 * @param up
	 *            If true, the TextField with the same or next smallest y
	 *            coordinate is found, else the next highest.
	 */
	public void next(
			boolean up )
	{
		if( stage == null )
			return;
		TextField3D textField = findNextTextField( stage.getActors() , null , up );
		if( textField != null )
			stage.setKeyboardFocus( textField );
		else
			Gdx.input.setOnscreenKeyboardVisible( false );
	}
	
	private TextField3D findNextTextField(
			List<Actor> actors ,
			TextField3D best ,
			boolean up )
	{
		for( int i = 0 , n = actors.size() ; i < n ; i++ )
		{
			Actor actor = actors.get( i );
			if( actor instanceof TextField3D )
			{
				if( actor == this )
					continue;
				if( actor.y == y )
				{
					if( best == null && actor.x >= x ^ up )
						best = (TextField3D)actor;
				}
				else if( actor.y < y ^ up && ( best == null || actor.y - y > best.y - y ^ up ) )
				{
					best = (TextField3D)actor;
				}
			}
			if( actor instanceof Group )
				best = findNextTextField( ( (Group)actor ).getActors() , best , up );
		}
		return best;
	}
	
	/**
	 * @param listener
	 *            May be null.
	 */
	public void setTextFieldListener(
			TextFieldListener listener )
	{
		this.listener = listener;
	}
	
	/**
	 * @param filter
	 *            May be null.
	 */
	public void setTextFieldFilter(
			TextFieldFilter filter )
	{
		this.filter = filter;
	}
	
	/** @return May be null. */
	public String getMessageText()
	{
		return messageText;
	}
	
	/**
	 * Sets the text that will be drawn in the text field if no text has been
	 * entered.
	 * 
	 * @parma messageText May be null.
	 */
	public void setMessageText(
			String messageText )
	{
		this.messageText = messageText;
	}
	
	/** @return Never null, might be an empty string. */
	public String getText()
	{
		return text;
	}
	
	public String getDisplayText()
	{
		return displayText;
	}
	
	/** Sets the selected text. */
	public void setSelection(
			int selectionStart ,
			int selectionEnd )
	{
		if( selectionStart < 0 )
			throw new IllegalArgumentException( "selectionStart must be >= 0" );
		if( selectionEnd < 0 )
			throw new IllegalArgumentException( "selectionEnd must be >= 0" );
		selectionStart = Math.min( text.length() , selectionStart );
		selectionEnd = Math.min( text.length() , selectionEnd );
		if( selectionEnd == selectionStart )
		{
			clearSelection();
			return;
		}
		if( selectionEnd < selectionStart )
		{
			int temp = selectionEnd;
			selectionEnd = selectionStart;
			selectionStart = temp;
		}
		hasSelection = true;
		this.selectionStart = selectionStart;
		cursor = selectionEnd;
	}
	
	public void clearSelection()
	{
		hasSelection = false;
	}
	
	/** Sets the cursor position and clears any selection. */
	public void setCursorPosition(
			int cursorPosition )
	{
		if( cursorPosition < 0 )
			throw new IllegalArgumentException( "cursorPosition must be >= 0" );
		clearSelection();
		cursor = Math.min( cursorPosition , text.length() );
	}
	
	public int getCursorPosition()
	{
		return cursor;
	}
	
	/** Default is an instance of {@link DefaultOnscreenKeyboard}. */
	public OnscreenKeyboard getOnscreenKeyboard()
	{
		return keyboard;
	}
	
	public void setOnscreenKeyboard(
			OnscreenKeyboard keyboard )
	{
		this.keyboard = keyboard;
	}
	
	public void setClipboard(
			Clipboard clipboard )
	{
		this.clipboard = clipboard;
	}
	
	/**
	 * If true, the text in this text field will be shown as bullet characters.
	 * The font must have character 149 or this will have no affect.
	 */
	public void setPasswordMode(
			boolean passwordMode )
	{
		this.passwordMode = passwordMode;
	}
	
	public void setText(
			String text )
	{
		this.text = text.trim();
		cursor = text.trim().length();
		updateDisplayText();
	}
	
	public void setTitleFontColor(
			int titleColor )
	{
		this.paint.setColor( titleColor );
		updateDisplayText();
	}
	
	@Override
	public void dispose()
	{
		// TODO Auto-generated method stub
		super.dispose();
		if( this.displayTextTexture != null )
		{
			if( displayTextTexture.getTexture() != null )
				displayTextTexture.getTexture().dispose();
		}
	}
	
	public void disposeDisplayTexture()
	{
		if( this.displayTextTexture != null )
		{
			if( displayTextTexture.getTexture() != null )
				displayTextTexture.getTexture().dispose();
		}
	}
}
